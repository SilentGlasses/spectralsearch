vim9script

# spectral_search.vim - Core implementation of Spectral Search plugin
# Maintainer: Generated by AI
# Version:    1.0
# License:    VIM License

# Internal variables
var spectral_matches: list<number> = []
var last_search_pattern: string = ''
var has_term_colors: bool = false
var highlight_groups: list<string> = []

# Heatmap visualization variables
var heatmap_enabled: bool = false
var heatmap_buffer: number = -1
var heatmap_window: number = -1
var heatmap_match_density: list<number> = []
var heatmap_width: number = 2
var heatmap_segments: number = 40
var heatmap_update_timer: number = -1
var heatmap_highlight_groups: list<string> = []

# Initialization
export def Initialize(): void
    # Check for terminal color support
    has_term_colors = has('termguicolors') && &termguicolors
    if !has_term_colors
        echo "Spectral Search: Limited color support detected. Using fallback colors."
    endif
    
    # Create initial highlight groups
    CreateHighlightGroups()
    
    # Set last search pattern to current search
    last_search_pattern = @/
    
    # Create heatmap highlight groups if needed
    CreateHeatmapHighlightGroups()
    
    # Initialize heatmap setting from global value
    if exists('g:spectral_search_heatmap')
        heatmap_enabled = g:spectral_search_heatmap
    endif
    
    # Initialize heatmap width from global value if set
    if exists('g:spectral_search_heatmap_width')
        heatmap_width = g:spectral_search_heatmap_width
    endif
    
    # Initialize heatmap segments from global value if set
    if exists('g:spectral_search_heatmap_segments')
        heatmap_segments = g:spectral_search_heatmap_segments
    endif
    
    echo "Spectral Search initialized."
enddef

# Toggle spectral search on/off
export def Toggle(): void
    g:spectral_search_enabled = !g:spectral_search_enabled
    
    if g:spectral_search_enabled
        ApplySpectralHighlights()
        echo "Spectral Search enabled"
    else
        ClearHighlights()
        echo "Spectral Search disabled"
    endif
enddef

# Set the gradient style
export def SetGradient(gradient: string): void
    if gradient != 'heat' && gradient != 'rainbow'
        echo "Invalid gradient style. Use 'heat' or 'rainbow'."
        return
    endif
    
    g:spectral_search_gradient = gradient
    if g:spectral_search_enabled
        # Re-apply with new gradient
        ClearHighlights()
        CreateHighlightGroups()
        ApplySpectralHighlights()
        echo "Spectral Search gradient set to " .. gradient
    endif
enddef

# Set the highlight intensity
export def SetIntensity(intensity: string): void
    if intensity != 'low' && intensity != 'medium' && intensity != 'high'
        echo "Invalid intensity. Use 'low', 'medium', or 'high'."
        return
    endif
    
    g:spectral_search_intensity = intensity
    if g:spectral_search_enabled
        # Re-apply with new intensity
        ClearHighlights()
        CreateHighlightGroups()
        ApplySpectralHighlights()
        echo "Spectral Search intensity set to " .. intensity
    endif
enddef

# Apply spectral highlights to search results
export def ApplySpectralHighlights(): void
    # Skip if disabled
    if !g:spectral_search_enabled
        return
    endif
    
    # Get the current search pattern
    var pattern = @/
    if pattern == ''
        return  # No search pattern
    endif
    
    # Save the pattern for later updates
    last_search_pattern = pattern
    
    # Apply highlights
    try
        # Clear existing highlights
        ClearHighlights()
        
        # Save current window for later restoration
        var current_window = win_getid()
        
        # Apply new highlights
        var window_id = win_getid()
        var num_matches = 0
        var total_matches = 0
        
        # Count total matches
        var save_cursor = getcurpos()
        setpos('.', [0, 1, 1, 0])
        while search(pattern, 'W') > 0 && total_matches < g:spectral_search_max_matches
            total_matches += 1
        endwhile
        setpos('.', save_cursor)
        
        # Reset cursor position
        setpos('.', [0, 1, 1, 0])
        
        # Apply highlights with priority decreasing for each match
        while search(pattern, 'W') > 0 && num_matches < g:spectral_search_max_matches
            # Get highlight group for this match
            var hl_group = GetHighlightGroup(num_matches, total_matches)
            
            # Get match position
            var line = line('.')
            var col = col('.')
            var end_col = col + len(matchstr(getline('.')[col - 1 :], pattern))
            
            # Add match with decreasing priority
            var priority = 100 - num_matches
            var match_id = matchaddpos(hl_group, [[line, col, end_col - col]], priority)
            add(spectral_matches, match_id)
            
            num_matches += 1
        endwhile
        
        # Restore cursor position
        setpos('.', save_cursor)
        
        # If no matches found, show a message
        if num_matches == 0 && pattern != ''
            echo "No matches for: " .. pattern
        endif
        
        # Update heatmap if enabled
        if heatmap_enabled && num_matches > 0
            UpdateHeatmapVisualization(pattern)
        elseif heatmap_enabled && num_matches == 0
            # Clear heatmap if no matches
            ClearHeatmap()
        endif
        
        # Return to original window
        win_gotoid(current_window)
    catch
        echohl ErrorMsg
        echom "Spectral Search error: " .. v:exception
        echohl None
    endtry
enddef

# Update highlights when text changes
export def UpdateHighlights(): void
    if !g:spectral_search_enabled || last_search_pattern == ''
        return
    endif
    
    # Check if search pattern changed
    if @/ != last_search_pattern
        last_search_pattern = @/
    endif
    
    # Reapply highlights
    ApplySpectralHighlights()
enddef

# Reapply highlights when colorscheme changes
export def ReapplyHighlights(): void
    if !g:spectral_search_enabled
        return
    endif
    
    CreateHighlightGroups()
    CreateHeatmapHighlightGroups()
    ApplySpectralHighlights()
enddef

# Clear all spectral highlights
export def ClearHighlights(): void
    # Remove all matches
    for id in spectral_matches
        try
            matchdelete(id)
        catch
            # Ignore errors if the match was already deleted
        endtry
    endfor
    
    # Clear the match list
    spectral_matches = []
    
    # Clear heatmap if enabled
    if heatmap_enabled
        ClearHeatmap()
    endif
enddef

# Show plugin information
export def ShowInfo(): void
    echo "Spectral Search Information:"
    echo "  Enabled:     " .. (g:spectral_search_enabled ? "Yes" : "No")
    echo "  Gradient:    " .. g:spectral_search_gradient
    echo "  Intensity:   " .. g:spectral_search_intensity
    echo "  Max Matches: " .. g:spectral_search_max_matches
    echo "  True Colors: " .. (has_term_colors ? "Yes" : "No (using fallback)")
    echo "  Matches:     " .. len(spectral_matches)
    echo "  Heatmap:     " .. (heatmap_enabled ? "Enabled" : "Disabled")
    if heatmap_enabled
        echo "  Heatmap Width:    " .. heatmap_width
        echo "  Heatmap Segments: " .. heatmap_segments
    endif
enddef

# Statusline integration
export def Statusline(): string
    if !g:spectral_search_enabled
        return ""
    endif
    
    var status = "SS:" .. g:spectral_search_gradient[0] .. ":" .. len(spectral_matches)
    
    # Add mini heatmap visualization to status line if enabled
    if heatmap_enabled && len(heatmap_match_density) > 0
        status ..= " " .. RenderStatuslineHeatmap()
    endif
    
    return status
enddef

# Completion function for gradient options
export def GradientComplete(arglead: string, cmdline: string, cursorpos: number): list<string>
    var options = ['heat', 'rainbow']
    return filter(options, (_, val) => val =~ '^' .. arglead)
enddef

# Completion function for intensity options
export def IntensityComplete(arglead: string, cmdline: string, cursorpos: number): list<string>
    var options = ['low', 'medium', 'high']
    return filter(options, (_, val) => val =~ '^' .. arglead)
enddef

# Completion function for heatmap width options
export def WidthComplete(arglead: string, cmdline: string, cursorpos: number): list<string>
    var options = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
    return filter(options, (_, val) => val =~ '^' .. arglead)
enddef

# Completion function for heatmap segments options
export def SegmentsComplete(arglead: string, cmdline: string, cursorpos: number): list<string>
    var options = ['10', '20', '30', '40', '50', '60', '70', '80', '90', '100']
    return filter(options, (_, val) => val =~ '^' .. arglead)
enddef

# Toggle heatmap visualization on/off
export def ToggleHeatmap(): void
    heatmap_enabled = !heatmap_enabled
    g:spectral_search_heatmap = heatmap_enabled
    
    if heatmap_enabled
        echo "Spectral Search Heatmap enabled"
        if last_search_pattern != ''
            # Force recalculation and visualization
            try
                # Close any existing window first to ensure clean creation
                CloseHeatmapWindow()
                
                # Calculate densities and create window
                heatmap_match_density = CalculateMatchDensity(last_search_pattern)
                CreateHeatmapWindow()
                
                # Show status
                echo "Heatmap created for pattern: " .. last_search_pattern
            catch
                echohl ErrorMsg
                echom "Failed to create heatmap: " .. v:exception
                echohl None
            endtry
        else
            echo "No search pattern available for heatmap"
        endif
    else
        echo "Spectral Search Heatmap disabled"
        CloseHeatmapWindow()
    endif
enddef

# Set heatmap width
export def SetHeatmapWidth(width: string): void
    var width_num = str2nr(width)
    if width_num < 1 || width_num > 10
        echo "Invalid heatmap width. Use a value between 1 and 10."
        return
    endif
    
    heatmap_width = width_num
    g:spectral_search_heatmap_width = heatmap_width
    
    if heatmap_enabled && last_search_pattern != ''
        echo "Heatmap width set to " .. width
        UpdateHeatmapVisualization(last_search_pattern)
    else
        echo "Heatmap width set to " .. width
    endif
enddef

# Set heatmap segments
export def SetHeatmapSegments(segments: string): void
    var segments_num = str2nr(segments)
    if segments_num < 10 || segments_num > 100
        echo "Invalid heatmap segments. Use a value between 10 and 100."
        return
    endif
    
    heatmap_segments = segments_num
    g:spectral_search_heatmap_segments = heatmap_segments
    
    if heatmap_enabled && last_search_pattern != ''
        echo "Heatmap segments set to " .. segments
        UpdateHeatmapVisualization(last_search_pattern)
    else
        echo "Heatmap segments set to " .. segments
    endif
enddef

# Helper functions

# Create highlight groups for spectral highlighting
def CreateHighlightGroups(): void
    # Clear previous highlight groups
    for group in highlight_groups
        execute 'highlight clear ' .. group
    endfor
    highlight_groups = []
    
    # Number of highlight groups to create
    var num_groups = 10
    
    # Generate colors based on gradient style
    for i in range(num_groups)
        var group_name = 'SpectralSearch' .. i
        var colors = GetColorForIndex(i, num_groups)
        
        # Define highlight group
        if has_term_colors
            execute 'highlight ' .. group_name .. ' guifg=' .. colors.fg .. ' guibg=' .. colors.bg
        else
            # Fallback for terminals without true color support
            var cterm_attrs = GetFallbackColors(i, num_groups)
            execute 'highlight ' .. group_name .. ' ctermfg=' .. cterm_attrs.fg .. ' ctermbg=' .. cterm_attrs.bg
        endif
        
        add(highlight_groups, group_name)
    endfor
enddef

# Get appropriate highlight group for a match
def GetHighlightGroup(match_index: number, total_matches: number): string
    # Scale the match index to our highlight groups
    var group_index = 0
    
    if total_matches > 1
        var scale = min([len(highlight_groups) - 1, total_matches - 1])
        group_index = float2nr(round(match_index * scale / (total_matches - 1)))
    endif
    
    return highlight_groups[group_index]
enddef

# Get colors for a specific index in the gradient
def GetColorForIndex(index: number, total: number): dict<string>
    var result = {fg: '#FFFFFF', bg: '#000000'}
    var normalized = (total > 1) ? index / (total - 1.0) : 0.0
    
    # Apply intensity factor
    var intensity = 1.0
    if g:spectral_search_intensity == 'low'
        intensity = 0.7
    elseif g:spectral_search_intensity == 'high'
        intensity = 1.2
    endif
    
    if g:spectral_search_gradient == 'heat'
        # Heat map: Blue -> Green -> Yellow -> Red
        if normalized < 0.25
            # Blue to Cyan
            var r = float2nr(round(normalized * 4 * 255 * intensity))
            result.bg = printf('#00%02X%02X', r, 255)
        elseif normalized < 0.5
            # Cyan to Green
            var b = float2nr(round((0.5 - normalized) * 4 * 255 * intensity))
            result.bg = printf('#00%02X%02X', 255, b)
        elseif normalized < 0.75
            # Green to Yellow
            var r = float2nr(round((normalized - 0.5) * 4 * 255 * intensity))
            result.bg = printf('#%02X%02X00', r, 255)
        else
            # Yellow to Red
            var g = float2nr(round((1.0 - normalized) * 4 * 255 * intensity))
            result.bg = printf('#%02X%02X00', 255, g)
        endif
        # Adjust foreground to ensure readability
        result.fg = (normalized > 0.5) ? '#000000' : '#FFFFFF'
    else
        # Rainbow: Red -> Orange -> Yellow -> Green -> Blue -> Indigo -> Violet
        var hue = float2nr(round(normalized * 300))  # 0-300 covers the spectrum
        var sat = float2nr(round(80 * intensity))
        var val = float2nr(round(90 * intensity))
        
        # Convert HSV to RGB
        result.bg = HSVtoHex(hue, sat, val)
        # Adjust foreground to ensure readability
        result.fg = (normalized > 0.3 && normalized < 0.7) ? '#000000' : '#FFFFFF'
    endif
    
    return result
enddef

# Get fallback colors for terminals without true color support
def GetFallbackColors(index: number, total: number): dict<number>
    var result = {fg: 15, bg: 0}  # Default: white on black
    var normalized = (total > 1) ? index / (total - 1.0) : 0.0
    
    # Basic 16-color terminal fallback
    if g:spectral_search_gradient == 'heat'
        # Heat map approximation with 16 colors
        if normalized < 0.25
            result.bg = 4  # Blue
        elseif normalized < 0.5
            result.bg = 6  # Cyan
        elseif normalized < 0.75
            result.bg = 2  # Green
        else
            result.bg = 1  # Red
        endif
        
        # Set foreground for readability
        result.fg = (normalized > 0.5) ? 0 : 15  # Black or White
    else
        # Rainbow approximation with 16 colors
        var rainbow_colors = [1, 3, 2, 6, 4, 5, 13]  # Red, Yellow, Green, Cyan, Blue, Magenta, Purple
        var idx = float2nr(round(normalized * (len(rainbow_colors) - 1)))
        result.bg = rainbow_colors[idx]
        
        # Set foreground for readability
        result.fg = (normalized > 0.3 && normalized < 0.7) ? 0 : 15  # Black or White
    endif
    
    return result
enddef

# Convert HSV to Hex color
def HSVtoHex(h_in: number, s_in: number, v_in: number): string
    # Create local variables to avoid modifying parameters
    var h_local = h_in % 360
    var s_local = s_in / 100.0
    var v_local = v_in / 100.0
    
    var c = v_local * s_local
    var x = c * (1 - abs((h_local / 60) % 2 - 1))
    var m = v_local - c
    
    var rgb = [0.0, 0.0, 0.0]
    
    if h_local < 60
        rgb = [c, x, 0.0]
    elseif h_local < 120
        rgb = [x, c, 0.0]
    elseif h_local < 180
        rgb = [0.0, c, x]
    elseif h_local < 240
        rgb = [0.0, x, c]
    elseif h_local < 300
        rgb = [x, 0.0, c]
    else
        rgb = [c, 0.0, x]
    endif
    
    # Apply m and convert to 0-255 range
    var r = float2nr(round((rgb[0] + m) * 255))
    var g = float2nr(round((rgb[1] + m) * 255))
    var b = float2nr(round((rgb[2] + m) * 255))
    
    # Ensure bounds
    r = max([0, min([r, 255])])
    g = max([0, min([g, 255])])
    b = max([0, min([b, 255])])
    
    return printf('#%02X%02X%02X', r, g, b)
enddef

# Heatmap visualization functions

# Calculate match density across the file
def CalculateMatchDensity(pattern: string): list<number>
    # Save current window and position
    var current_win = win_getid()
    var save_cursor = getcurpos()
    var result: list<number> = []
    
    # Initialize density array with zeros
    for i in range(heatmap_segments)
        add(result, 0)
    endfor
    
    # Get total line count
    var total_lines = line('$')
    if total_lines < 1
        return result
    endif
    
    # Calculate lines per segment
    var lines_per_segment = max([1, float2nr(ceil(total_lines / heatmap_segments))])
    
    # Count matches in each segment
    setpos('.', [0, 1, 1, 0])
    var match_count = 0
    
    while search(pattern, 'W') > 0
        var current_line = line('.')
        var segment_index = min([heatmap_segments - 1, float2nr(floor(current_line / lines_per_segment))])
        result[segment_index] += 1
        match_count += 1
        
        # Limit to prevent long loops
        if match_count >= g:spectral_search_max_matches * 2
            break
        endif
    endwhile
    
    # Restore cursor position
    setpos('.', save_cursor)
    win_gotoid(current_win)
    
    return result
enddef

# Create highlight groups for heatmap visualization
def CreateHeatmapHighlightGroups(): void
    # Clear previous highlight groups
    for group in heatmap_highlight_groups
        execute 'highlight clear ' .. group
    endfor
    heatmap_highlight_groups = []
    
    # Number of highlight groups to create
    var num_groups = 10
    
    # Generate colors for heatmap density
    for i in range(num_groups)
        var group_name = 'SpectralHeatmap' .. i
        var normalized = i / (num_groups - 1.0)
        var colors = {fg: '#FFFFFF', bg: '#000000'}
        
        # Heatmap color: Blue -> Green -> Yellow -> Red
        if normalized < 0.25
            # Low density - Blue to Cyan
            var r = float2nr(round(normalized * 4 * 255))
            colors.bg = printf('#00%02X%02X', r, 255)
        elseif normalized < 0.5
            # Medium-low - Cyan to Green
            var b = float2nr(round((0.5 - normalized) * 4 * 255))
            colors.bg = printf('#00%02X%02X', 255, b)
        elseif normalized < 0.75
            # Medium-high - Green to Yellow
            var r = float2nr(round((normalized - 0.5) * 4 * 255))
            colors.bg = printf('#%02X%02X00', r, 255)
        else
            # High density - Yellow to Red
            var g = float2nr(round((1.0 - normalized) * 4 * 255))
            colors.bg = printf('#%02X%02X00', 255, g)
        endif
        
        # Define highlight group (foreground is not used for heatmap, just bg)
        if has_term_colors
            execute 'highlight ' .. group_name .. ' guibg=' .. colors.bg .. ' guifg=' .. colors.bg
        else
            # Fallback for terminals without true color support
            # Fallback for terminals without true color support
            var cterm_idx = float2nr(round(normalized * 6))
            var cterm_colors = [4, 6, 2, 3, 1, 9] # Blue, Cyan, Green, Yellow, Red, Bright Red
            var cterm_bg = cterm_colors[min([len(cterm_colors) - 1, cterm_idx])]
            execute 'highlight ' .. group_name .. ' ctermbg=' .. cterm_bg .. ' ctermfg=' .. cterm_bg
        endif
        
        add(heatmap_highlight_groups, group_name)
    endfor
enddef

# Update the heatmap visualization based on current search
def UpdateHeatmapVisualization(pattern: string): void
    try
        # Calculate match density
        heatmap_match_density = CalculateMatchDensity(pattern)
        
        # Create or update the heatmap window
        if heatmap_buffer == -1 || !bufexists(heatmap_buffer) || heatmap_window == -1 || win_id2win(heatmap_window) <= 0
            # Full creation needed
            CreateHeatmapWindow()
        else
            # Just update the content
            UpdateHeatmapWindow()
        endif
    catch
        echohl ErrorMsg
        echom "Error updating heatmap: " .. v:exception
        echohl None
    endtry
enddef

# Create a new heatmap window
def CreateHeatmapWindow(): void
    # Save current window
    var current_win = win_getid()
    
    try
        # First, close any existing heatmap window to avoid duplicates
        CloseHeatmapWindow()
        
        # Create a new buffer if needed
        if heatmap_buffer == -1 || !bufexists(heatmap_buffer)
            # Create a new buffer
            heatmap_buffer = bufadd('SpectralHeatmap')
            bufload(heatmap_buffer)
        endif
        
        # Set buffer options (regardless of whether buffer is new or existing)
        setbufvar(heatmap_buffer, '&buftype', 'nofile')
        setbufvar(heatmap_buffer, '&bufhidden', 'hide')
        setbufvar(heatmap_buffer, '&swapfile', 0)
        setbufvar(heatmap_buffer, '&modifiable', 1)
        setbufvar(heatmap_buffer, '&filetype', 'spectralheatmap')
        setbufvar(heatmap_buffer, '&buflisted', 0)
        
        # Create a new window at the far right
        execute 'botright vertical ' .. heatmap_width .. 'new'
        
        # Set the buffer in this window
        execute 'buffer ' .. heatmap_buffer
        
        # Verify window was created with our buffer
        if bufnr('%') != heatmap_buffer
            throw "Failed to create heatmap window with correct buffer"
        endif
        
        # Set window options using setlocal for better reliability
        setlocal nonumber
        setlocal norelativenumber
        setlocal nowrap
        setlocal nolist
        setlocal nocursorline
        setlocal nocursorcolumn
        setlocal signcolumn=no
        setlocal foldcolumn=0
        setlocal buftype=nofile
        setlocal bufhidden=hide
        setlocal noswapfile
        setlocal nobuflisted
        
        # Window persistence
        setwinvar(win_getid(), '&winfixwidth', 1)
        setwinvar(win_getid(), '&winfixheight', 1)
        setwinvar(win_getid(), '&colorcolumn', '')
        setwinvar(win_getid(), '&statusline', '')
        setwinvar(win_getid(), '&scrollbind', 0)
        
        # Force exact width (multiple times to ensure it takes effect)
        execute 'vertical resize ' .. heatmap_width
        
        # Save window ID for later reference
        heatmap_window = win_getid()
        
        # Make window visually distinct
        setwinvar(win_getid(), '&winhl', 'Normal:SpectralHeatmap5')
        
        # Update the window content immediately
        UpdateHeatmapWindow()
        
        # Force width again after content is added
        execute 'vertical resize ' .. heatmap_width
        redraw!
        
        # Return to original window
        if win_id2win(current_win) > 0
            win_gotoid(current_win)
        endif
    catch
        echohl ErrorMsg
        echom "Error creating heatmap window: " .. v:exception
        echohl None
        
        # Try to return to original window
        if win_id2win(current_win) > 0
            win_gotoid(current_win)
        endif
    endtry
enddef

# Update the content of the heatmap window
def UpdateHeatmapWindow(): void
    # Check if the buffer and window exist
    if heatmap_buffer == -1 || !bufexists(heatmap_buffer)
        CreateHeatmapWindow()
        return
    endif
    
    # Save current window
    var current_win = win_getid()
    var window_exists = heatmap_window != -1 && win_id2win(heatmap_window) > 0
    
    # Get the window if it exists
    if window_exists
        try
            win_gotoid(heatmap_window)
        catch
            CreateHeatmapWindow()
            return
        endtry
    else
        CreateHeatmapWindow()
        return
    endif
    
    # Make buffer modifiable
    setbufvar(heatmap_buffer, '&modifiable', 1)
    
    # Clear the buffer content
    silent execute '%delete _'
    
    # Find the maximum density
    var max_density = 0
    for density in heatmap_match_density
        max_density = max([max_density, density])
    endfor
    
    # Generate heatmap content
    var lines = []
    var total_lines = line('$', current_win)
    var line_height = total_lines / heatmap_segments
    
    for idx in range(len(heatmap_match_density))
        var density = heatmap_match_density[idx]
        var normalized = max_density > 0 ? density / max_density : 0
        var group_idx = min([len(heatmap_highlight_groups) - 1, float2nr(round(normalized * (len(heatmap_highlight_groups) - 1)))])
        var hl_group = heatmap_highlight_groups[group_idx]
        
        # Calculate line number range for this segment
        var start_line = idx * line_height + 1
        var end_line = min([total_lines, (idx + 1) * line_height])
        
        # Add line with appropriate highlighting
        var char = density > 0 ? '█' : '·'
        var line = repeat(char, heatmap_width)
        add(lines, line)
    endfor
    
    # Add lines to buffer
    setline(1, lines)
    
    # Apply syntax highlighting for each segment
    syntax clear
    for idx in range(len(heatmap_match_density))
        var density = heatmap_match_density[idx]
        var normalized = max_density > 0 ? density / max_density : 0
        var group_idx = min([len(heatmap_highlight_groups) - 1, float2nr(round(normalized * (len(heatmap_highlight_groups) - 1)))])
        var hl_group = heatmap_highlight_groups[group_idx]
        
        # Define syntax match for this line
        execute 'syntax match ' .. hl_group .. ' /\%' .. (idx + 1) .. 'l.*/'
    endfor
    
    # Make buffer non-modifiable
    setbufvar(heatmap_buffer, '&modifiable', 0)
    
    # Return to original window
    win_gotoid(current_win)
enddef

# Close the heatmap window
def CloseHeatmapWindow(): void
    # Check if window exists
    if heatmap_window != -1 && win_id2win(heatmap_window) > 0
        # Save current window
        var current_win = win_getid()
        
        # Close the window
        try
            win_gotoid(heatmap_window)
            silent! close
            
            # Return to original window if it still exists
            if win_id2win(current_win) > 0
                win_gotoid(current_win)
            endif
        catch
            # Window might be already closed
            echom "Note: Heatmap window was already closed"
        endtry
    endif
    
    # Reset window ID
    heatmap_window = -1
enddef

# Clear the heatmap
def ClearHeatmap(): void
    # Clear match density data
    heatmap_match_density = []
    
    # Close the window if it exists
    CloseHeatmapWindow()
    
    # Reset buffer if it exists
    if heatmap_buffer != -1 && bufexists(heatmap_buffer)
        try
            # Save current window
            var current_win = win_getid()
            
            # Make buffer modifiable
            setbufvar(heatmap_buffer, '&modifiable', 1)
            
            # Find a window showing the buffer or open in hidden buffer
            var buf_win = bufwinid(heatmap_buffer)
            if buf_win > 0
                win_gotoid(buf_win)
            else
                execute 'sbuffer ' .. heatmap_buffer
            endif
            
            # Clear the buffer content
            silent execute '%delete _'
            
            # Go back to previous window
            if buf_win <= 0  # We created a new window
                silent execute 'quit'
            endif
            
            # Return to original window
            if win_id2win(current_win) > 0
                win_gotoid(current_win)
            endif
            
            # Reset buffer ID
            heatmap_buffer = -1
        catch
            echohl ErrorMsg
            echom "Error clearing heatmap buffer: " .. v:exception
            echohl None
            heatmap_buffer = -1  # Reset anyway
        endtry
    endif
enddef

# Render a compact heatmap for the statusline
def RenderStatuslineHeatmap(): string
    if len(heatmap_match_density) == 0
        return ''
    endif
    
    # Find the maximum density
    var max_density = 0
    for density in heatmap_match_density
        max_density = max([max_density, density])
    endfor
    
    # Create a compact visualization using block characters
    var result = ''
    var chars = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█']
    var compact_segments = min([10, len(heatmap_match_density)])
    var step = len(heatmap_match_density) / compact_segments
    
    for i in range(compact_segments)
        var start_idx = float2nr(i * step)
        var end_idx = float2nr((i + 1) * step) - 1
        
        # Calculate average density for this segment
        var sum = 0
        for j in range(start_idx, end_idx)
            if j < len(heatmap_match_density)
                sum += heatmap_match_density[j]
            endif
        endfor
        
        var avg = (end_idx - start_idx + 1) > 0 ? sum / (end_idx - start_idx + 1) : 0
        var normalized = max_density > 0 ? avg / max_density : 0
        var char_idx = min([len(chars) - 1, float2nr(round(normalized * (len(chars) - 1)))])
        
        result ..= chars[char_idx]
    endfor
    
    return result
enddef

# Sync heatmap scroll position with main window
export def SyncHeatmapScroll(): void
    if !heatmap_enabled || heatmap_window == -1 || win_id2win(heatmap_window) <= 0
        return
    endif
    
    try
        # Get current window info
        var current_win = win_getid()
        var current_topline = line('w0')
        var current_bottomline = line('w$')
        var total_lines = line('$')
        
        # Calculate approximate position in heatmap
        var midpoint = (current_topline + current_bottomline) / 2
        var fraction = midpoint / total_lines
        
        # Get heatmap window height
        win_gotoid(heatmap_window)
        var heatmap_height = line('$')
        
        # Calculate and set scroll position
        var heatmap_line = max([1, min([heatmap_height, float2nr(fraction * heatmap_height)])])
        execute 'normal! ' .. heatmap_line .. 'G'
        execute 'normal! z.'
        
        # Return to original window
        win_gotoid(current_win)
    catch
        # Ignore errors
    endtry
enddef
